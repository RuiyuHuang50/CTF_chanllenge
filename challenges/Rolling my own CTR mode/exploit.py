#!/usr/bin/env python3

"""
Exploit for Rolling my own CTR mode challenge

Key insight: The vulnerability is in the key derivation:
AES_key = (counter_bytes + original_key)[:32]

This means:
- Block 0 uses key: (b'\x00' + KEY)[:32] = KEY[:32] when counter_length=1
- Block 1 uses key: (b'\x01' + KEY)[:32] = (b'\x01' + KEY[:31])
- etc.

The attack vector:
1. We can manipulate the first byte (counter_length) of any ciphertext
2. This changes how the counter bytes are interpreted
3. We can potentially create a ciphertext that decrypts to "open sesame"
"""

import socket
import time

def connect_to_server():
    """Connect to the challenge server"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('cpuk.bootupctf.net', 8093))
        return s
    except Exception as e:
        print(f"Connection failed: {e}")
        return None

def send_and_receive(sock, data):
    """Send data and receive response"""
    sock.send(data.encode() + b'\n')
    time.sleep(0.1)
    response = sock.recv(4096).decode()
    return response

def exploit():
    """
    Main exploit strategy:
    
    1. Encrypt a known plaintext to understand the ciphertext format
    2. Manipulate the counter_length byte to change key derivation
    3. Try to create a ciphertext that decrypts to "open sesame"
    """
    
    sock = connect_to_server()
    if not sock:
        return
    
    try:
        # Read initial message
        initial = sock.recv(4096).decode()
        print("Server:", initial)
        
        # Step 1: Encrypt a test message to understand the format
        print("\n=== Step 1: Encrypt test message ===")
        test_msg = "hello world test"
        
        response = send_and_receive(sock, "e")
        print("Server:", response)
        
        response = send_and_receive(sock, test_msg)
        print("Encrypted:", response)
        
        if response.strip():
            ciphertext_hex = response.strip()
            ciphertext = bytes.fromhex(ciphertext_hex)
            counter_length = ciphertext[0]
            print(f"Counter length: {counter_length}")
            print(f"Ciphertext blocks: {len(ciphertext[1:]) // 16}")
            
            # Step 2: Try to manipulate the ciphertext
            print("\n=== Step 2: Attempting manipulation ===")
            
            # Strategy: Try different counter_length values
            for new_counter_length in range(1, 5):
                print(f"\nTrying counter_length = {new_counter_length}")
                
                # Create modified ciphertext with new counter_length
                modified_ciphertext = bytes([new_counter_length]) + ciphertext[1:]
                
                response = send_and_receive(sock, "d")
                print("Server:", response)
                
                response = send_and_receive(sock, modified_ciphertext.hex())
                print("Decrypted:", response)
                
                if "open sesame" in response:
                    print("SUCCESS! Found the flag!")
                    break
                    
        sock.close()
        
    except Exception as e:
        print(f"Error: {e}")
        sock.close()

def manual_mode():
    """Manual interaction mode for testing"""
    sock = connect_to_server()
    if not sock:
        return
        
    try:
        # Read initial message
        initial = sock.recv(4096).decode()
        print("Server:", initial)
        
        print("Manual mode - type commands:")
        print("Commands: e (encrypt), d (decrypt), q (quit)")
        
        while True:
            cmd = input("Command: ")
            if cmd == 'q':
                break
                
            response = send_and_receive(sock, cmd)
            print("Server:", response)
            
            if cmd in ['e', 'd']:
                data = input("Data: ")
                response = send_and_receive(sock, data)
                print("Result:", response)
                
                if "bootup{" in response:
                    print("FLAG FOUND!")
                    break
                    
    except KeyboardInterrupt:
        print("\nExiting...")
    finally:
        sock.close()

if __name__ == "__main__":
    print("=== Rolling my own CTR mode Exploit ===")
    
    mode = input("Choose mode: [a]uto exploit or [m]anual? ").lower()
    
    if mode.startswith('a'):
        exploit()
    else:
        manual_mode()
